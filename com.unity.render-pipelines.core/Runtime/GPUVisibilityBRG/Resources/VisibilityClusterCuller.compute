#pragma kernel MainWriteVisibleInstances
#pragma kernel MainWriteIndirectArgs
#pragma kernel MainWriteVisibleClusters
#pragma kernel MainWriteVisibleIndices
#pragma kernel MainWriteIndexDrawArguments

#include "Packages/com.unity.render-pipelines.core/Runtime/GeometryPool/Resources/GeometryPool.hlsl"
#include "Packages/com.unity.render-pipelines.core/Runtime/GPUVisibilityBRG/GPUVisibilityCuller.cs.hlsl"

//#pragma enable_d3d11_debug_symbols

#define GROUP_SIZE 64
#define InvalidValue 0xffffffff

int _TotalInstanceCount;
ByteAddressBuffer _InputInstances;
RWByteAddressBuffer _InstanceOutCounter;
RWByteAddressBuffer _VisibleInstanceBuffer;

bool IsInstanceVisible(uint instanceID)
{
    //TODO: test visibility against frustum here
    return true;
}

[numthreads(GROUP_SIZE,1,1)]
void MainWriteVisibleInstances(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    if (dispatchThreadID.x >= (uint)_TotalInstanceCount)
        return;

    uint instanceOffset = dispatchThreadID.x;
    uint instanceID = _InputInstances.Load(instanceOffset << 2);

    if (!IsInstanceVisible(instanceID))
        return;

    uint outInstanceIndex;
    _InstanceOutCounter.InterlockedAdd(0, 1, outInstanceIndex);

    _VisibleInstanceBuffer.Store(outInstanceIndex << 2, instanceID);
}

int _MaxCounterValue;
int _ArgsGroupSize;
ByteAddressBuffer _InputCounterBuffer;
RWStructuredBuffer<uint> _OutIndirectArgs;

[numthreads(1,1,1)]
void MainWriteIndirectArgs()
{
    uint counter = (uint)min(_InputCounterBuffer.Load(0), _MaxCounterValue);
    _OutIndirectArgs[0] = (counter + _ArgsGroupSize - 1) / _ArgsGroupSize;
    _OutIndirectArgs[1] = 1;
    _OutIndirectArgs[2] = 1;
}

int _DeferredMaterialInstanceDataAddress;
int _MaxOutputClusterOffset;
ByteAddressBuffer _BigInstanceBuffer;
ByteAddressBuffer _InputInstanceCounter;
ByteAddressBuffer _InputVisibleInstanceBuffer;
RWByteAddressBuffer _ClustersOutCounter;
RWByteAddressBuffer _OutVisibleClustersBuffer;

uint packVisibleClusterInfo(uint instanceID, uint clusterIndex)
{
    return (instanceID & 0xFFFF) | (clusterIndex << 16);
}

void unpackVisibleClusterInfo(uint visibleClusterInfo, out uint outInstanceID, out uint outClusterIndex)
{
    outClusterIndex = visibleClusterInfo >> 16;
    outInstanceID = visibleClusterInfo & 0xFFFF;
}

[numthreads(GROUP_SIZE,1,1)]
void MainWriteVisibleClusters(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint numOfInstances = _InputInstanceCounter.Load(0);
    if (dispatchThreadID.x >= (uint)numOfInstances)
        return;

    uint instanceID = _InputVisibleInstanceBuffer.Load(dispatchThreadID.x << 2);
    uint geoHandle = (uint)asfloat(_BigInstanceBuffer.Load(_DeferredMaterialInstanceDataAddress + instanceID * 16));
    GeoPoolMeshEntry meshEntry = GeometryPool::GetMeshEntry(geoHandle);

    uint clusterOutputIndex;
    _ClustersOutCounter.InterlockedAdd(0, meshEntry.clustersCounts, clusterOutputIndex);
    if (clusterOutputIndex >= (uint)_MaxOutputClusterOffset)
        return;

    //naively write visible clusters.
    [loop]
    for (int i = 0; i < meshEntry.clustersCounts; ++i)
    {
        uint clusterIndex = (uint)(meshEntry.clustersBufferIndex + i);
        _OutVisibleClustersBuffer.Store((clusterOutputIndex + i) << 2, packVisibleClusterInfo(instanceID, clusterIndex));
    }
}

RWByteAddressBuffer _OutputVisibilityIndices;

uint packIndexData(uint clusterOffset, int indexOffset)
{
    return (clusterOffset << 8) | (indexOffset & 0xFF);
}

void unpackIndexData(uint indexData, out uint outClusterOffset, out uint outIndexOffset)
{
    outClusterOffset = indexData >> 8;
    outIndexOffset = indexData & 0xFF;
}

[numthreads(GROUP_SIZE,1,1)]
void MainWriteVisibleIndices(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint indicesPerPrimitive = GEO_POOL_CLUSTER_PRIMITIVE_COUNT * 3;
    for (int primitiveID = 0; primitiveID < GEO_POOL_CLUSTER_PRIMITIVE_COUNT; ++primitiveID)
    {
        uint3 data = uint3(
            packIndexData(dispatchThreadID.x, primitiveID * 3 + 0),
            packIndexData(dispatchThreadID.x, primitiveID * 3 + 1),
            packIndexData(dispatchThreadID.x, primitiveID * 3 + 2));
        _OutputVisibilityIndices.Store3((dispatchThreadID.x * indicesPerPrimitive + primitiveID*3) << 2, data);
    }
}

ByteAddressBuffer _InputClusterCounts;
RWStructuredBuffer<BRGDrawCallArgument> _OutDrawIndexedArguments;

[numthreads(1,1,1)]
void MainWriteIndexDrawArguments()
{
    BRGDrawCallArgument args;
    args.vertexOffset = 0;
    args.vertexCount = 0;
    args.indexOffset = 0;
    args.indexCount = _InputClusterCounts.Load(0) * GEO_POOL_CLUSTER_PRIMITIVE_COUNT * 3;
    args.instanceCount = 1;
    _OutDrawIndexedArguments[0] = args;
}
